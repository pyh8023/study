Trino根据生成的逻辑执行计划将其拆分成多个具有层级关系的Stage，每个Stage会进一步分解为若干个Task，并将Task调度到不同的Worker节点上执行，每个的Stage有不同的调度策略。

查询调度的入口在SqlQueryExecution.start()中，根据不同的重试策略选择QueryScheduler实现类：

```
private void planDistribution(PlanRoot plan)
    {
        // if query was canceled, skip creating scheduler
        if (stateMachine.isDone()) {
            return;
        }

        // record output field
        PlanFragment rootFragment = plan.getRoot().getFragment();
        stateMachine.setColumns(
                ((OutputNode) rootFragment.getRoot()).getColumnNames(),
                rootFragment.getTypes());

        RetryPolicy retryPolicy = getRetryPolicy(getSession());
        QueryScheduler scheduler;
        switch (retryPolicy) {
            case QUERY:
            case NONE:
                scheduler = new PipelinedQueryScheduler(
                        stateMachine,
                        plan.getRoot(),
                        nodePartitioningManager,
                        nodeScheduler,
                        remoteTaskFactory,
                        plan.isSummarizeTaskInfos(),
                        scheduleSplitBatchSize,
                        queryExecutor,
                        schedulerExecutor,
                        failureDetector,
                        nodeTaskMap,
                        executionPolicy,
                        schedulerStats,
                        dynamicFilterService,
                        tableExecuteContextManager,
                        plannerContext.getMetadata(),
                        splitSourceFactory,
                        coordinatorTaskManager);
                break;
            case TASK:
                if (isFaultTolerantExecutionEventDriverSchedulerEnabled(stateMachine.getSession())) {
                    scheduler = new EventDrivenFaultTolerantQueryScheduler(
                            stateMachine,
                            plannerContext.getMetadata(),
                            remoteTaskFactory,
                            taskDescriptorStorage,
                            eventDrivenTaskSourceFactory,
                            plan.isSummarizeTaskInfos(),
                            nodeTaskMap,
                            queryExecutor,
                            schedulerExecutor,
                            schedulerStats,
                            partitionMemoryEstimatorFactory,
                            nodePartitioningManager,
                            exchangeManagerRegistry.getExchangeManager(),
                            nodeAllocatorService,
                            failureDetector,
                            dynamicFilterService,
                            taskExecutionStats,
                            plan.getRoot());
                }
                else {
                    scheduler = new FaultTolerantQueryScheduler(
                            stateMachine,
                            queryExecutor,
                            schedulerStats,
                            failureDetector,
                            taskSourceFactory,
                            taskDescriptorStorage,
                            exchangeManagerRegistry.getExchangeManager(),
                            nodePartitioningManager,
                            getTaskRetryAttemptsOverall(getSession()),
                            getTaskRetryAttemptsPerTask(getSession()),
                            getMaxTasksWaitingForNodePerStage(getSession()),
                            schedulerExecutor,
                            nodeAllocatorService,
                            partitionMemoryEstimatorFactory,
                            taskExecutionStats,
                            dynamicFilterService,
                            plannerContext.getMetadata(),
                            remoteTaskFactory,
                            nodeTaskMap,
                            plan.getRoot(),
                            plan.isSummarizeTaskInfos());
                }
                break;
            default:
                throw new IllegalArgumentException("Unexpected retry policy: " + retryPolicy);
        }

        queryScheduler.set(scheduler);
    }
```

然后调用QueryScheduler的start()方法启动查询调度。

当重试策略为NONE或QUERY时，采用PipelinedQueryScheduler进行调度，重试策略为TASK时，采用EventDrivenFaultTolerantQueryScheduler和FaultTolerantQueryScheduler，其中FaultTolerantQueryScheduler已过时，已被EventDrivenFaultTolerantQueryScheduler取代，下面主要对PipelinedQueryScheduler和EventDrivenFaultTolerantQueryScheduler进行分析。



# QueryScheduler

## PipelinedQueryScheduler
PipelinedQueryScheduler的大致调度过程如下图所示：

![image-pipelinedQueryScheduler](../trino/images/image-pipelinedQueryScheduler.png)

在PipelinedQueryScheduler中创建PipelinedQueryScheduler.CoordinatorStagesScheduler 和PipelinedQueryScheduler.DistributedStagesScheduler两个Stage调度器：
PipelinedQueryScheduler.CoordinatorStagesScheduler负责Coordinator_Only类型的Stage调度
PipelinedQueryScheduler.DistributedStagesScheduler负责Coordinator_Only类型之外的所有Stage的调度



## EventDrivenFaultTolerantQueryScheduler
